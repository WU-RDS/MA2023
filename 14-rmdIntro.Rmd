

```{r, echo=FALSE, warning=FALSE}
library(knitr)
#rm(list = ls())
#This code automatically tidies code so that it does not reach over the page
opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=TRUE, rownames.print = FALSE, rows.print = 10)
```

# (PART) Assignments {-}

# R Markdown 


## Introduction to R Markdown

::: {.infobox .download data-latex="{download}"}
[You can download the example markdown file here](./Code/rmarkdown_example.Rmd)
:::

This page will guide you through creating and editing R Markdown documents. This is a useful tool for reporting your analysis (e.g. for homework assignments). Of course, there is also [a cheat sheet for R-Markdown](https://www.rstudio.org/links/r_markdown_cheat_sheet) and [this book](https://bookdown.org/yihui/rmarkdown/) contains a comprehensive discussion of the format. 

The following video contains a short introduction to the R Markdown format.

<br>
<div align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/o8FdyMAR-g4" frameborder="0" allowfullscreen></iframe>
</div>
<br>

### Creating a new R Markdown document {-}

In addition to the video, the following text contains a short description of the most important formatting options.  

Let's start to go through the steps of creating and .Rmd file and outputting the content to an HTML file. 

0. If an R-Markdown file was provided to you, open it with R-Studio and skip to [step 4](#step4) after adding your answers.

1. Open R-Studio

2. Create a new R-Markdown document
![](./rmdExplain/start.PNG)
![](./rmdExplain/openDoc.PNG)
![](./rmdExplain/enterName.PNG)
![](./rmdExplain/template.PNG)

3. Save with appropriate name
![](./rmdExplain/saving.PNG)

    3.1. Add your answers

    3.2. Save again

 <a name="step4"></a>
 
4. "Knit" to HTML 
![](./rmdExplain/knit.PNG)

5. Hand in appropriate file (ending in `.html`) on learn\@WU
![](./rmdExplain/handin.PNG)

### Text and Equations {-}

R-Markdown documents are plain text files that include both text and R-code. Using RStudio they can be converted ('knitted') to HTML or PDF files that include both the text and the results of the R-code. In fact this website is written using R-Markdown and RStudio. In order for RStudio to be able to interpret the document you have to use certain characters or combinations of characters when formatting text and including R-code to be evaluated. By default the document starts with the options for the text part. You can change the title, date, author and a few more advanced options. 

![First lines of an R-Markdown document](./rmdExplain/rmdHead.PNG)

The default is text mode, meaning that lines in an Rmd document will be interpreted as text, unless specified otherwise.

#### Headings {-}

Usually you want to include some kind of heading to structure your text. A heading is created using `#` signs. A single `#` creates a first level heading, two `##` a second level and so on. 

![](./rmdExplain/headings.PNG)

It is important to note here that the ```#``` symbol means something different within the code chunks as opposed to outside of them. If you continue to put a ```#``` in front of all your regular text, it will all be interpreted as a first level heading, making your text very large.

#### Lists {-}

Bullet point lists are created using `*`, `+` or `-`. Sub-items are created by indenting the item using 4 spaces or 2 tabs. 

````
* First Item
* Second Item
    + first sub-item
        - first sub-sub-item
    + second sub-item
````
* First Item
* Second Item
    + first sub-item
        - first sub-sub-item
    + second sub-item


Ordered lists can be created using numbers and letters. If you need sub-sub-items use `A)` instead of `A.` on the third level. 

````
1. First item
    a. first sub-item
        A) first sub-sub-item 
     b. second sub-item
2. Second item
````

1. First item
    a. first sub-item
        A) first sub-sub-item
    b. second sub-item
2. Second item


#### Text formatting {-}

Text can be formatted in *italics* (`*italics*`) or **bold** (`**bold**`). In addition, you can ad block quotes with `>`

````
> Lorem ipsum dolor amet chillwave lomo ramps, four loko green juice messenger bag raclette forage offal shoreditch chartreuse austin. Slow-carb poutine meggings swag blog, pop-up salvia taxidermy bushwick freegan ugh poke.
````
> Lorem ipsum dolor amet chillwave lomo ramps, four loko green juice messenger bag raclette forage offal shoreditch chartreuse austin. Slow-carb poutine meggings swag blog, pop-up salvia taxidermy bushwick freegan ugh poke.

### R-Code {-}

R-code is contained in so called "chunks". These chunks always start with three backticks and ```r``` in curly braces (``` ```{r} ```) and end with three backticks (``` ``` ```). Optionally, parameters can be added after the ```r``` to influence how a chunk behaves. Additionally, you can also give each chunk a name. Note that these have to be **unique**, otherwise R will refuse to knit your document.

#### Global and chunk options {-}

The first chunk always looks as follows


    ```{r setup, include = FALSE}`r ''`
    knitr::opts_chunk$set(echo = TRUE)
    ```

It is added to the document automatically and sets options for all the following chunks. These options can be overwritten on a per-chunk basis. 

Keep `knitr::opts_chunk$set(echo = TRUE)` to print your code to the document you will hand in. Changing it to `knitr::opts_chunk$set(echo = FALSE)` will not print your code by default. This can be changed on a per-chunk basis.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

    ```{r cars, echo = FALSE}`r ''`
    summary(cars)

    plot(dist~speed, cars)
    ```


```{r cars, echo = FALSE}
summary(cars)

plot(dist~speed, cars)
```

 
    ```{r cars2, echo = TRUE}`r ''`
    summary(cars)

    plot(dist~speed, cars)
    ```


```{r cars2, echo = TRUE}
summary(cars)

plot(dist~speed, cars)
```

A good overview of all available global/chunk options can be found [here](https://yihui.name/knitr/options/#chunk_options).

### LaTeX Math {-}

Writing well formatted mathematical formulas is done the same way as in [LaTeX](https://en.wikipedia.org/wiki/LaTeX). Math mode is started and ended using `$$`. 
````
$$
 f_1(\omega) = \frac{\sigma^2}{2 \pi},\ \omega \in[-\pi, \pi]
$$
````

$$
 f_1(\omega) = \frac{\sigma^2}{2 \pi},\ \omega \in[-\pi, \pi]
$$

(for those interested this is the spectral density of [white noise](https://en.wikipedia.org/wiki/White_noise))

Including inline mathematical notation is done with a single ```$``` symbol. 

````
${2\over3}$ of my code is inline.

````
${2\over3}$ of my code is inline.

<br>

Take a look at [this wikibook on Mathematics in LaTeX](https://en.wikibooks.org/wiki/LaTeX/Mathematics#Symbols) and [this list of Greek letters and mathematical symbols](https://www.sharelatex.com/learn/List_of_Greek_letters_and_math_symbols) if you are not familiar with LaTeX.

In order to write multi-line equations in the same math environment, use `\\` after every line. In order to insert a space use a single `\`. To render text inside a math environment use `\text{here is the text}`. In order to align equations start with `\begin{align}` and place an `&` in each line at the point around which it should be aligned. Finally end with `\end{align}`

````
$$
\begin{align}
\text{First equation: }\ Y &= X \beta + \epsilon_y,\ \forall X \\
\text{Second equation: }\ X &= Z \gamma + \epsilon_x
\end{align}
$$
````

$$
\begin{align}
\text{First equation: }\ Y &= X \beta + \epsilon_y,\ \forall X \\
\text{Second equation: }\ X &= Z \gamma + \epsilon_x
\end{align}
$$

#### Important symbols {-}

```{r, echo=FALSE, include=TRUE, results="asis", warning = FALSE}
library(knitr)
library(kableExtra)

lat <- readLines("./lat.txt")

lat1 <- paste0("$", lat, "$")
lat2 <- paste0("```", lat, "```")

mathy.df <- data.frame(Symbol = lat1, Code = lat2) 

kable(mathy.df, escape=FALSE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

The `{}` after `_` and `^` are not strictly necessary if there is only one character in the sub-/superscript. However, in order to place multiple characters in the sub-/superscript they are necessary. 
e.g.


```{r, echo=FALSE, include=TRUE, results="asis", warning = FALSE}
lat <- readLines("./lat2.txt")

lat1 <- paste0("$", lat, "$")
lat2 <- paste0("```", lat, "```")

mathy.df <- data.frame(Symbol = lat1, Code = lat2) 

kable(mathy.df, escape=FALSE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

#### Greek letters {-}

[Greek letters](https://en.wikipedia.org/wiki/Greek_alphabet#Letters) are preceded by a `\` followed by their name (`$\beta$` = $\beta$). In order to capitalize them simply capitalize the first letter of the name (`$\Gamma$` = $\Gamma$).

<!--

## Assignment 1

We'll use the music data set from the last session as the basis for the assignment. 

Please use R to solve the tasks. When you finished the assignment, click on the "Knit to HTML" in the RStudio menu. This will create an html document in the folder in which the assignment1.Rmd file is stored. Open this file in your browser to check if everything is correct. If you are happy with the output, pleas submit the .html-file via the assignment on Learn\@WU using the following file name: "assignment1_studendID_lastname.html".

We'll first load the data that is needed for the assignment.

```{r load_data, message = FALSE, warning = FALSE}
library(dplyr)
library(psych)
library(ggplot2)

music_data <- read.csv2("https://raw.githubusercontent.com/WU-RDS/RMA2022/main/data/music_data_fin.csv",
                        sep = ";", header = TRUE, dec = ",")
str(music_data)
head(music_data) 
```

You should then convert the variables to the correct types:  
  
```{r convert_variables, message=FALSE, warning=FALSE}
music_data <-  music_data %>% 
  mutate(label = as.factor(label), # convert label and genre variables to factor with values as labels
         genre = as.factor(genre)) %>% as.data.frame()
```

### Q1

Create a new data frame containing the most successful songs of the artist "Billie Eilish" by filtering the original data set by the artist "Billie Eilish" and order the observations in an descending order.  

```{r question_1, message = FALSE, warning = FALSE}
billie_eilish <- music_data %>% 
  select(artistName,trackName,streams) %>% #select relevant variables
  filter(artistName == "Billie Eilish") %>% #filter by artist name
  arrange(desc(streams)) #arrange by number of streams (in descending order)
billie_eilish #print output
```

### Q2

Create a new data frame containing the 100 overall most successful songs in the data frame and order them descending by the number of streams.

Here you could simply arrange the whole data set by streams and then take 100 first rows using the `head()`-function:
  
```{r question_2, message = FALSE, warning = FALSE}
top_100 <- music_data %>% 
  select(artistName,trackName,streams) %>% #select relevant variables
  arrange(desc(streams)) %>% #arrange by number of streams (in descending order)
  head(100) #select first 100 observations
top_100
```

### Q3

Which genres are most popular? Group the data by genre and compute the sum of streams by genre. 

Using `dplyr` functions, you could first group the observations by genre, then summarize the streams using `sum()`:
  
```{r question_3_1, message = FALSE, warning = FALSE}
genres_popularity <- music_data %>% 
  group_by(genre) %>% #group by genre
  summarize(streams = sum(streams)) #compute sum of streams per genre
genres_popularity
```

### Q4

Which music label is most successful? Group the data by music label and compute the sum of streams by label and the average number of streams for all songs associated with a label. 

Just like in the previous task, it would be enough to group the observations (in this case, by labels), and get the sums and averages of streams:
  
```{r question_4_1, message = FALSE, warning = FALSE}
label_success <- music_data %>% 
  group_by(label) %>% #group by label
  summarize(sum_streams = sum(streams),
            avg_streams = mean(streams)) #compute sum of streams and average streams per label
label_success
```

### Q5

How do the songs differ in terms of the song features? Please first select the relevant variables (7 song features) and compute the descriptive statistics for these variables by genre.     

All audio features (danceability, energy, speechiness, instrumentalness, liveness, valence, and tempo) are variables measured on a **ratio scale**, which means that we can evaluate their **average values**. We can use `describeBy()` function, which displays mean by default alongside with range and other values:
  
```{r question_5_1, message = FALSE, warning = FALSE}
library(psych)
describeBy(select(music_data, 
                  danceability, energy, speechiness, instrumentalness, liveness, valence, tempo), 
           music_data$genre, skew = FALSE) 
```


### Q6

How many songs in the data set are associated with each label? 
  
You could use `table()` to get the number of songs by label:
  
```{r question_6, message = FALSE, warning = FALSE}
table(music_data$label)
```


### Q7

Which share of streams do the different genres account for?
  
```{r question_7, message = FALSE, warning = FALSE}
genre_streams <- music_data %>% 
  group_by(genre) %>%
  summarise(genre_streams=sum(streams)) #first compute sum of streams by genre
genre_streams_share <- genre_streams %>%
  mutate(genre_share = genre_streams/sum(genre_streams)) #then divide the sum by the total streams
genre_streams_share
```

### Q8

Create a histogram for the variable "Valence" 

This is a simple plot of valence distribution across all songs in your data (we can see that it follows normal distribution):
  
```{r question_8, message = FALSE, warning = FALSE, fig.cap=c("Distribution of valence"), fig.align="center", echo=TRUE}
ggplot(music_data,aes(x = valence)) + 
  geom_histogram(binwidth = 4, col = "white", fill = "lavenderblush3") + 
  labs(x = "Valence", y = "Frequency") +
  theme_minimal()
```

### Q9

Create a grouped boxplot for the variable "energy" by genre.

```{r question_9, message = FALSE, warning = FALSE, fig.cap=c("Boxplot of energy by genre"), fig.align="center", echo=TRUE}
ggplot(music_data, aes(x = genre, y = energy, color = genre)) + 
  geom_boxplot(coef = 3) + 
  labs(x = "Genre", y = "Energy") + 
  theme_minimal() + 
  coord_flip()
```

### Q10

Create a scatterplot for the variables "valence" and "energy"

Finally, we can visualize the relationship between valence and energy of songs in our data:
  
```{r question_10, message = FALSE, warning = FALSE, fig.cap=c("Scatterplot of energy and valence"), fig.align="center", echo=TRUE}
ggplot(music_data, aes(x = valence, y = energy)) +
  geom_point(shape = 1) + 
  labs(x = "Valence", y = "Energy") +
  theme_minimal()
```



## Assignment 2  

**Assignment 2a**

**Load data**

```{r warning=F, message=F, echo=T, eval=T}
library(pastecs)
library(ggplot2)
library(psych)
library(pwr)
library(lsr)
library(reshape2)
library(ggstatsplot)
library(Rmisc)
library(plyr)
library(car)
options(scipen = 999) #scientific notation
customer_data_a <- read.table("https://raw.githubusercontent.com/WU-RDS/MA2022/main/data/data_1.csv", 
                          sep = ",", 
                          header = TRUE) #read in data
#head(customer_data_a)
#str(customer_data_a)
```


### Q1  

Let's have a quick look at the revenues that we have in our data:
```{r message=FALSE, warning=FALSE, fig.align="center"}
psych::describe(customer_data_a$revenue)

ggplot(customer_data_a, aes(revenue)) + 
  geom_histogram(col = "white", fill = "lavenderblush3", bins = 50) + 
  geom_vline(data = customer_data_a %>% dplyr::summarise(mean = mean(revenue)),aes(xintercept = mean), size = 0.7, color = "gray19") +
  labs(x = "Revenue", y = "Frequency") + 
  ggtitle("Distribution of revenue per customer") +
  theme_minimal()
```

To compute the confidence interval for the average revenue per customer, we will need three things: 1) the *mean* $\bar x$, 2) the *standard error* ($s \over \sqrt{n}$), and 3) the *critical value* for a t-distribution ($t_{crit}$; we will use a t-distribution, because we are not sure of the variance in the population; for this assignment, also the normal distribution and the corresponding $z$-score would have been counted as correct).

```{r warning=F, message=F, echo=T, eval=T}
mean <- mean(customer_data_a$revenue) #calculate the mean
sd <- sd(customer_data_a$revenue) 
n <- nrow(customer_data_a)
se <- sd/sqrt(n) #calculate the standard error
df <- n-1
t_crit <- qt(0.975, df) #calculate the critical value
```

The confidence interval can be computed as follows: 
$$CI_{rev} = \bar x \pm t_{ \alpha \over 2}*SE_{\bar x}$$
  
```{r}
ci_lower <- mean - t_crit * se
ci_upper <- mean + t_crit * se
ci_lower
ci_upper
```

You could also use one-sample `t.test()` function to calculate the CIs around the mean:

```{r}
t.test(customer_data_a$revenue)$conf.int
```

We can see now that the confidence interval for revenues is $CI_{rev} = [1364.34,1439.50]$.
To communicate this information with the accounting department, you should interpret the intervals as follows: **If we'd taken 100 samples and calculated the mean and confidence interval for each of them, then the true population mean would be included in 95% of these intervals. In the sample at hand, this interval spans from 1364.34 to 1439.50 EUR**.  
  
  

### Q2

First we will analyze whether the personalization feature that was tested in the A/B-test had an effect on *revenues*. We need to formulate a hypothesis which we can test. In this case, *the null hypothesis is that the feature had no effect on the mean revenue*, i.e. that there is **no difference in the mean revenue between the two populations**. The alternative hypothesis states that the campaign *did have an effect*, meaning that there is a difference in the mean revenue between the populations. In more formal notation this is:

$$H_0: \mu_0 = \mu_1 \\ H_1: \mu_0 \neq \mu_1$$

We need to transform the variable *exp_group* into a factor variable and inspect the data using descriptive statistics:
```{r warning=F, message=F, echo=T, eval=T}
customer_data_a$exp_group <- factor(customer_data_a$exp_group, 
                                    levels = c(0,1), labels = c("control", "treatment"))

describeBy(customer_data_a$revenue, customer_data_a$exp_group) #describe control and treatment groups 
```
It can already be seen that the mean revenue is higher in the treatment group. 

Next, we should visualize the data. For this, we can use plot of means or boxplot:
```{r warning = F, message = F, echo=T, eval=T, fig.show="hold", out.width="50%"}
mean_data <- summarySE(customer_data_a, measurevar = "revenue", 
    groupvars = c("exp_group"))

#Plot of means
ggplot(mean_data, aes(x = exp_group, y = revenue)) + 
    geom_bar(position = position_dodge(0.9), fill = "lavenderblush3", stat = "identity", width = 0.50) + 
    geom_errorbar(position = position_dodge(0.9), width = 0.15, aes(ymin = revenue - ci, ymax = revenue + ci)) + 
    theme_minimal() + 
    labs(x = "Experiment group", y = "Average revenue", title = "Average revenue by group") + 
    theme(plot.title = element_text(hjust = 0.5, color = "#666666"))

#Boxplot
ggplot(customer_data_a, aes(x = exp_group, y = revenue)) + geom_boxplot() +
    geom_jitter(alpha = 0.2, color = "lavenderblush4") + 
    labs(x = "Experiment group", y = "Revenue", title = "Boxplot of revenue by group") + 
    theme_minimal()
```

As we can see in both the descriptive statistics and the plot, the revenues were higher for the group that was exposed to the new personalization feature. To test whether or not this difference is significant, we need to use an __independent-means t-test__, since we have different customers in each group, meaning that we have collected the data using a between-subjects design (i.e., the customers in one condition are *independent* of the customers in the other condition). The requirements are clearly met:

* Our dependent variable (revenue) is measured on an ratio scale;
* Since we have more than 30 observations per group we do not really have to concern ourselves with whether the data is normally distributed or not (see central limit theorem);
* If a customer was exposed to the feature or not was assigned randomly (i.e., the groups are independent);
* R automatically performs Welch's t-test, which corrects for unequal variance.  

```{r warning = F, message = F, echo=T, eval=T}
t.test(revenue ~ exp_group, data = customer_data_a)
```

The test is significant, since the **p-value is smaller than 0.05**, leading us to **reject the null hypothesis that there is no difference in the mean revenue**. The p-value states the probability of finding a difference of the observed magnitude or higher, if the null hypothesis was in fact true (i.e., if there was in fact no difference between the populations). Effectively, this means that **the personalization feature had an effect on the average expenditure**. Another thing we can extract from this test result is the confidence interval around the difference in means. **Since 0** (i.e., hypothetical difference in means from H0) **is not included in the interval**, it is not a plausible value, confirming the conclusion to reject the null hypothesis.

We should also calculate the effect size:
```{r warning = F, message = F, echo=T, eval=T}
cohensD(revenue ~ exp_group, data = customer_data_a)
```
This magnitude of the effect size (0.30) suggests that the **effect of the personalization feature on the revenue is small to medium**.

We can visualize the results of the test using `ggstatsplot`:
```{r message=FALSE, warning=FALSE, fig.align="center"}
ggbetweenstats(
  data = customer_data_a,
  plot.type = "box",
  x = exp_group, #2 groups
  y = revenue ,
  type = "p", #default
  effsize.type = "d", #display effect size (Cohen's d in output)
  messages = FALSE,
  bf.message = FALSE,
  mean.ci = TRUE,
  title = "Average revenue per customer by group"
) 
```

The results show that revenues are **higher in the treatment group (Mean = 1506.27, SE = 27.56) compared to the control group (Mean = 1288.58, SE = 25.81)**. This means that, on average, the revenues were **€217.69 higher** in the treatment group, compared to the control group. An independent-means t-test showed that **this difference is significant: t(1426.2) = 5.77, p < .05 (95% CI = [143.62, 291.76]); effect size is small to medium = 0.30**.


Now we can test if the new personalization feature has an effect on *time spent on our website*. 
```{r}
describeBy(customer_data_a$time_on_site, customer_data_a$exp_group) #describe control and treatment groups for time on site
```

```{r warning = F, message = F, echo=T, eval=T, fig.show="hold", out.width="50%"}
mean_data_time <- summarySE(customer_data_a, measurevar = "time_on_site", 
                            groupvars = c("exp_group"))

#Plot of means
ggplot(mean_data_time, aes(x = exp_group, y = time_on_site)) + 
  geom_bar(position = position_dodge(0.9), fill = "lavenderblush3", stat = "identity", width = 0.50) + 
  geom_errorbar(position = position_dodge(0.9), width = 0.15, aes(ymin = time_on_site - ci, ymax = time_on_site + ci)) + 
  theme_minimal() + labs(x = "Experiment group", y = "Average time on site", title = "Average time on site by group") + 
  theme(plot.title = element_text(hjust = 0.5, color = "#666666"))

#Boxplot
ggplot(customer_data_a, aes(x = exp_group, y = time_on_site)) + geom_boxplot() +
  geom_jitter(alpha = 0.2, color = "lavenderblush4") + 
  labs(x = "Experiment group", y = "Time on site", title = "Boxplot of time on site by group") + 
  theme_minimal()
```

There is some difference in average time spent on site, however, we need to conduct a statistical test. We are examining if there is difference in mean time on site between the populations; our formal notation for the null and alternative hypotheses stays the same:
$$H_0: \mu_0 = \mu_1 \\ H_1: \mu_0 \neq \mu_1$$
  
We use the __independent-means t-test__ again:
  
* The dependent variable (time on site) is measured on an ratio scale
* We still have more than 30 observations per group
* The groups are independent

```{r warning = F, message = F, echo=T, eval=T}
t.test(time_on_site ~ exp_group, data = customer_data_a)
cohensD(time_on_site ~ exp_group, data = customer_data_a)
```

The test results show that the difference that we observed before is **not statistically significant as p-value is >0.05**. Alternatively, we can see that **the confidence interval around the difference in means includes 0** (which is the value of difference in means from the null hypothesis). Therefore, **we cannot reject the null hypothesis**. The effect is very small.

```{r message=FALSE, warning=FALSE, fig.align="center"}
ggbetweenstats(
  data = customer_data_a,
  plot.type = "box",
  x = exp_group, #2 groups
  y = time_on_site,
  type = "p", # default
  effsize.type = "d", #display effect size (Cohen's d in output)
  messages = FALSE,
  bf.message = FALSE,
  mean.ci = TRUE,
  title = "Average time on site per customer by group"
)
```

This test revealed that time on site was **slightly higher in the treatment group (Mean = 640.45, SE = 10.52) compared to the control group (Mean = 626.28, SE = 10.92)**. This difference is **not statistically significant: t(1418.3) = 0.93, p > .05 (95% CI = [-15.56; 43.92])**.


Finally, we can conclude from this study that the personalization feature causes users to increase their expenditures, but does not result in increased time spent on the website. If the primary goal of the company is to increase the revenues, this feature might be implemented on the website.  


### Q3
  
  To define the number of users that should be placed in two different conditions, `pwr.t.test()` function should be used. As far as the aim of the experiment is to simply detect *significant difference* between the groups, the sample size definition should be based on *two-sided test*.  

Given the **effect size = 0.1**, **significance level = 0.05**, and **power = 0.8**, sample size for each group will be:
```{r}
pwr.t.test(d = 0.1, sig.level = 0.05, power = 0.8, type = c("two.sample"), alternative = c("two.sided"))
```

To achieve our desired effect size of 0.1, a significance level of 0.5 and a power of 0.8 we would need to include **at least 1,571 customers per group** in the planned experiment.


**Assignment 2b:**

### Q4  
  
**Load data**
  
```{r warning=F, message=F, echo=T, eval=T}
customer_data_b <- read.table("https://raw.githubusercontent.com/WU-RDS/MA2022/main/data/data_2.csv", 
                              sep = ",", 
                              header = TRUE) #read in data
#head(customer_data_b)
#str(customer_data_b)
```

Next we want to examine whether the alternative page layout has an effect on the time that a user spends on the website. The null hypothesis here is that *there is no difference in the mean time spend on the website for the same customers between the two page layouts*. Because the observations come from *the same population* of customers (i.e., a within-subject design), we refer to the difference in the means for the same population as $\mu_D$ when stating our hypotheses. The alternative hypothesis states that that *there is a difference* between the time on site variables for the same customers. In mathematical notation this can be written as

$$H_0: \mu_D = 0 \\ H_1: \mu_D \neq 0$$
  
Again, we start with descriptive statistics to get a feel for the data: 
```{r}
psych::describe(customer_data_b[!is.na(customer_data_b$time_on_site_2), c("time_on_site_1","time_on_site_2")])
```


We can observe the difference in means from the table above; we can also visualize the data:
```{r warning = F, message = F, paged.print = FALSE, echo=T, eval=T, fig.show="hold", out.width="50%"}
#Plot of means
customer_data_long <- melt(customer_data_b[!is.na(customer_data_b$time_on_site_2), c("time_on_site_1", "time_on_site_2")])
names(customer_data_long) <- c("layout", "time_on_site")

mean_data <- summarySE(customer_data_long, measurevar = "time_on_site", 
                       groupvars = c("layout"))

#Plot of means
ggplot(mean_data, aes(x = layout, y = time_on_site)) + 
  geom_bar(position = position_dodge(0.9), fill = "lavenderblush3", stat = "identity", width = 0.5) + 
  geom_errorbar(position = position_dodge(0.9), width = 0.15, aes(ymin = time_on_site - ci, ymax = time_on_site + ci)) + 
  theme_minimal() + labs(x = "", y = "Average time on site", title = "Average time on site by group") + 
  theme(plot.title = element_text(hjust = 0.5, color = "#666666"))

#Boxplot
ggplot(customer_data_long, aes(x = layout, y = time_on_site)) + geom_boxplot() +
  geom_jitter(alpha = 0.2, color = "lavenderblush4") + 
  labs(x = "", y = "Revenue", title = "Boxplot of revenue by group") + 
  theme_minimal()
```
It appears that there is a difference in the means. To test whether it is significant, we need to run a t-test again. However, this time we need a slightly different version of the t-test because *the same customers* are observed for the two page layouts (i.e., the same customers are shown both layouts). This means that we need a __dependent means t-test__, or **paired samples t-test**. The other assumptions are virtually identical to the independent-means t-test. The test can be executed in R by adding ```paired = TRUE``` to the code.   

```{r}
t.test(customer_data_b$time_on_site_2, customer_data_b$time_on_site_1, 
       mu = 0, alternative = "two.sided", conf.level = 0.95,
       paired = TRUE)
```

The p-value is again lower than the chosen significance level of 5% (i.e., p < .05), which means that we can reject the null hypothesis that there is no difference in the mean time on site between the two page layouts. The confidence interval confirms the conclusion to reject the null hypothesis since $0$ is not contained in the range of plausible values.

We can now find out how strong this effect is: it is actually rather small.
```{r warning = FALSE, echo=T, eval=T}
cohensD(customer_data_b$time_on_site_1, customer_data_b$time_on_site_2, method = 'paired')
```

Alternatively, you could also use the `ggstatsplot` package to conduct the tests and extract the relevant information from there: 
  
```{r message=FALSE, warning=FALSE, fig.align="center"}
ggwithinstats(
  data = customer_data_long,
  x = layout,
  y = time_on_site,
  path.point = FALSE,
  path.mean = TRUE,
  title = "Time on site for different page layouts",
  messages = FALSE,
  bf.message = FALSE,
  mean.ci = TRUE,
  effsize.type = "d" # display effect size (Cohen's d in output)
)
```


The results of this experiment show that, on average, **the same users used the service more** when it included the alternative layout **(M = 747.55, SE = 11.06)** compared to the service without the previous personalization feature only **(M = 625.27, SE = 10.36)**. This difference was significant: **t(740) = 8.01, p < .05 (95% CI = [92.30, 152.25]); effect size is small = 0.29**. 

The conclusion from this test would be that the alternative page layout increases the time that users spend on the website and, thus, the alternative layout might be implemented as the new standard. 


**Assignment 2c:**

### Q5  
  
**Load data**
  
```{r warning=F, message=F, echo=T, eval=T}
customer_data_c <- read.table("https://raw.githubusercontent.com/WU-RDS/MA2022/main/data/data_3.csv", 
                              sep = ",", 
                              header = TRUE) #read in data
#head(customer_data_c)
#str(customer_data_c)
```

To answer the question of whether the type of advertising has an effect on revenue, we need to formulate a testable null hypothesis. In our case, the null hypothesis is stating that **the average level of sales is equal for all three advertising types**. In mathematical notation this implies:
$$H_0: \mu_1 = \mu_2 = \mu_3 $$
  
The alternate hypothesis is simply that the means are not all equal, i.e., 
$$H_1: \exists {i,j}: {\mu_i \ne \mu_j} $$
or $$H_1: \textrm{Means are not all equal} $$
  
The appropriate test for such a hypothesis is one-way ANOVA since we have a *metric-scaled dependent variable* and a *categorical independent variable with more than two levels*.

First, we need to recode relevant variables into factors and give them more descriptive level names: 
```{r}
customer_data_c$retargeting <- factor(customer_data_c$retargeting, levels = c(1,2,3), labels = c("no retargeting", "generic retargeting", "dynamic retargeting"))
```

Next we calculate summary statistics for the data and build an appropriate plot.
```{r warning = F, message = F, paged.print = FALSE, echo=T, eval=T, fig.show="hold", out.width="50%"}
describeBy(customer_data_c$revenue, customer_data_c$retargeting)

#Plot of means
mean_data_2 <- summarySE(customer_data_c, measurevar = "revenue", groupvars = c("retargeting"))
ggplot(mean_data_2, aes(x = retargeting, y = revenue)) + 
  geom_bar(position = position_dodge(1), fill = "lavenderblush3", stat = "identity", width = 0.5) +
  geom_errorbar(position = position_dodge(.9), width = .15, aes(ymin = revenue - ci, ymax = revenue + ci)) +
  theme_minimal() +
  labs(x = "", y = "Average revenue", title = "Average revenue by group")+
  theme(plot.title = element_text(hjust = 0.5, color = "#666666")) 

#Boxplot
ggplot(customer_data_c, aes(x = retargeting, y = revenue)) + 
  geom_boxplot() +
  geom_jitter(colour = "lavenderblush4", alpha = 0.1) +
  theme_minimal() +
  labs(x = "", y = "Revenue")+
  theme(plot.title = element_text(hjust = 0.5, color = "#666666")) 
```

Both the summary statistics and the plots hint at the fact that the means may not be equal. Especially the difference between dynamic retargeting and no retargeting/generic regtargeting seem to be quite high. Before we move to the formal test, we need to see if a series of **assumptions** are met, namely:
  
* Independence of observations
* Distributional assumptions
* Homogeneity of variances

The first assumption is satisfied due to the fact that *the participants were randomly assigned* to the advertisement groups. To see if we need to worry about distributional assumptions we first take a look at the number of observations in each advertising group.

```{r warning=FALSE, message=FALSE}
table(customer_data_c$retargeting) #check number of observations by group
```
Due to the fact that there are always *more than 30 observations in each group* we can rely on the central limit theorem to satisfy the distributional assumptions. You can still test this assumption using Shapiro-Wilk normality test and plots:
```{r warning = F, message = F, fig.show="hold", out.width="30%"}
#test for normal distribution of variables - no need because n > 30
by(customer_data_c$revenue, customer_data_c$retargeting, shapiro.test)
#shapiro.test(customer_data_c[customer_data_c$retargeting == "no retargeting", ]$revenue)
#shapiro.test(customer_data_c[customer_data_c$retargeting == "generic retargeting", ]$revenue)
#shapiro.test(customer_data_c[customer_data_c$retargeting == "dynamic retargeting", ]$revenue)
qqnorm(customer_data_c[customer_data_c$retargeting == "no retargeting", ]$revenue) 
qqline(customer_data_c[customer_data_c$retargeting == "no retargeting", ]$revenue)
qqnorm(customer_data_c[customer_data_c$retargeting == "generic retargeting", ]$revenue) 
qqline(customer_data_c[customer_data_c$retargeting == "generic retargeting", ]$revenue)
qqnorm(customer_data_c[customer_data_c$retargeting == "dynamic retargeting", ]$revenue) 
qqline(customer_data_c[customer_data_c$retargeting == "dynamic retargeting", ]$revenue)
```


Homogeneity of variances can be checked with *Levene's test* (implemented as ```leveneTest()``` from the ```car``` package). The null hypothesis of this test is that the variances are equal, with the alternative hypothesis being that the variances are not all equal. Note that this step could also be skipped and replaced by the use of the robust ANOVA using the `oneway.test()` function. 
```{r}
leveneTest(revenue ~ retargeting, data = customer_data_c)
```

As we can see, we cannot reject the H0 of variances being equal, thus we can proceed with ANOVA. 
```{r}
aov <- aov(revenue ~ retargeting, data = customer_data_c)
summary(aov) #if levene's test would be significant, compute the Welch's F-ratio instead
lsr::etaSquared(aov)
summary(aov)[[1]]$'Sum Sq'[1]/(summary(aov)[[1]]$'Sum Sq'[1] + summary(aov)[[1]]$'Sum Sq'[2]) #another way
```

Or, as was mentioned, you could also run a more robust test with `oneway.test()`:
```{r}
oneway.test(revenue ~ retargeting, data = customer_data_c)
```

In both tests, the **p-value is way smaller than 0.05**, which we chose as our significance level, meaning that we **reject the null hypothesis of the means being equal** in the three advertising groups. 

Again, there is an option to show the test results in a graph:
```{r fig.align="center", echo=TRUE, message = FALSE, warning = FALSE, fig.width=6, fig.height=5}
library(ggstatsplot)
ggbetweenstats(
  data = customer_data_c,
  x = retargeting,
  y = revenue,
  plot.type = "box",
  pairwise.comparisons = TRUE,
  pairwise.annotation = "p.value",
  p.adjust.method = "bonferroni",
  effsize.type = "eta", #if var.equal = FALSE, returns partial eta^2 
  var.equal = TRUE,
  mean.plotting = TRUE, 
  mean.ci = TRUE, 
  mean.label.size = 2.5,
  type = "parametric", 
  k = 3, 
  outlier.label.color = "darkgreen", 
  title = "Comparison of revenues between groups",
  xlab = "Experimental group", 
  ylab = "Revenue", 
  messages = FALSE,
  bf.message = FALSE,
)
```

Next we will briefly inspect the residuals of the ANOVA to see if the assumptions of the test really are justified.
```{r warning = F, message = F, paged.print = FALSE, echo=T, eval=T, figures-side, fig.show="hold", out.width="50%"}
plot(aov,1)
plot(aov,2)
```

The first plot gives us a feel for the distribution of the residuals of the three groups. The residuals seem to be roughly equally distributed, which speaks for the fact that *the homogeneity of variances assumption is fulfilled*. 

The second plot is a QQ-plot of the residuals, meant as a quick visual check to see if the normality assumption is fulfilled. Leading up to the test we only checked if there were more than 30 observations per group to satisfy the normality assumption but despite this being fulfilled it is still important to check the normality of the residuals, as any strange behavior here may indicate problems with the model specification. 

To further confirm that the residuals are roughly normally distributed we employ the **Shapiro-Wilk test**. The null hypothesis is that the distribution of the data is normal, with the alternative hypothesis positing that the data is not normally distributed.

```{r warning=FALSE, message=FALSE, echo=T, eval=T}
shapiro.test(resid(aov))
```

The p-value is above the significance level and thus we cannot reject the null hypothesis of normal distribution, which further implies that *the normality assumption is fulfilled*.

According to the test, the effect of different types of advertising on revenues was detected: **F(2, 2201) = 57.16, p < 0.05, $\eta^2$ = 0.049**.

The ANOVA result only tells us that *the means of the three groups are not equal*, but it does not tell us anything about _which_ pairs of means are unequal. To find this out we need to conduct **post-hoc tests** to check the following null hypotheses for the respective pairwise comparisons:

$$1) H_0: \mu_1 = \mu_2; H_1: \mu_1 \neq \mu_2 \\
2) H_0: \mu_2 = \mu_3; H_1: \mu_2 \neq \mu_3 \\
3) H_0: \mu_1 = \mu_3; H_1: \mu_1 \neq \mu_3 $$

Here we will conduct both the Bonferroni correction as well as Tukey's HSD test, however, either would be sufficient for your homework. Bonferroni's correction conducts multiple pairwise t-tests, with the null hypothesis being that of equal means in each case and the alternative hypothesis stating that the means are unequal.

```{r warning = F, message = F, echo=T, eval=T}
#bonferroni
pairwise.t.test(customer_data_c$revenue, customer_data_c$retargeting, data = customer_data_c, p.adjust.method = "bonferroni")
```


According to the Bonferroni test, we can **reject the null hypotheses in all cases**, which means that the revenue means are significantly different from each other:
dynamic regargeting vs. no retargeting  
dynamic regargeting vs. generig retargeting
generic retargeting vs. no retargeting

Alternatively, you could have also chosen to use Tukey's HSD to conduct the post-hoc test:
```{r warning = F, message = F, echo=T, eval=T}
#tukey correction using the mult-comp package
library(multcomp)
tukeys <- glht(aov, linfct = mcp(retargeting = "Tukey"))
summary(tukeys)
```
Tukey's correction confirms the conclusion from the Bonferroni test. There seems to be difference in the means of generic retargeting vs. no retargeting, and dynamic retargeting vs. both generic retargeting and no retargeting. 

We can estimate the difference in means with corresponding confidence intervals:
```{r warning = F, message = F, fig.align='center', fig.height=4, echo=T, eval=T}
confint(tukeys)
par(mar = c(5,19,4,2)) #the mar parameter changes the margins around created plots. This is done so the labels on the side of the Tukey plot are visible (however, this was not expected)
plot(tukeys)
```

It is clearly visible that none of the CIs cross the 0 bound (it's not even visible), which further indicates that all differences in means are statistically significantly different from 0.

From a reporting standpoint we can say that revenue is higher when using dynamic retargeting vs. no retargeting and generic retargeting; generic retargeting is though also more effective than no retargeting. Managerially, this means that dynamic retargeting helps us to increase sales and should thus be the preferred choice. 

### Q6

For this question we want to examine whether the scores from the NPS measurement are significantly different for the experimental groups (i.e., *three* types of retargeting). Because we are dealing with data on an **ordinal scale**, we can not use ANOVA for this analysis. The non-parametric counterpart is the Kruskal-Wallis test, which tests for differences in medians between more than two groups. Hence, the null hypothesis is that **the medians are equal in each group**, and the alternative hypothesis is that there is a difference in medians. 

$$H_0: \bar{\mu}_1 =  \bar{\mu}_2 = \bar{\mu}_3  \\ H_1: \bar{\mu}_1 \neq \bar{\mu}_2 \neq \bar{\mu}_3 $$

Let's inspect the descriptive statistics first:
  
```{r warning = F, message = F, echo=T, eval=T}
# Descriptive statistics for NPS, split by group
describeBy(customer_data_c$nps, customer_data_c$retargeting)
```

A good way to visualize ordinal data is through a boxplot.
```{r fig.align="center", warning = F, message = F, echo=T, eval=T, fig.height=5, fig.width=5.5}
ggplot(data = customer_data_c, aes(x = retargeting, y = nps)) + 
  geom_boxplot(color = 'lavenderblush4') + 
  geom_jitter(colour="lavenderblush3", alpha = 0.1) +
  theme_minimal() + 
  labs(x = "", y = "Rank")
```

The descriptive statistics and boxplot seem to indicate that the median NPS without retargeting and with generic retargetng is the same; median NPS for dynamic retargeting is slightly higher. The reason might be, for example, that due to the use of dynamic retargeting, customers spend more money (as was shown in ANOVA), but it doesn't result in higher NPS, possibly because customers are not comfortable with the use of their personal data for advertising purposes.  

The only assumption that we require for this test is that the *dependent variable is at least ordinal*, which is fulfilled for customer ranks. Hence we can move on to performing the test:

```{r warning = F, message = F}
kruskal.test(nps ~ retargeting, data = customer_data_c) 
```

```{r fig.align="center", echo=TRUE, message = FALSE, warning = FALSE, fig.width=6, fig.height=5}
ggbetweenstats(
  data = customer_data_c,
  plot.type = "box",
  x = retargeting, #3 groups
  y = nps,
  type = "nonparametric",
  pairwise.comparisons = TRUE,
  pairwise.annotation = "p.value",
  p.adjust.method = "bonferroni",
  messages = FALSE,
  title = "Median NPS for different retargeting groups"
)
```


The **p-value is below 0.05 and thus we reject the null hypothesis of equal medians**. This means that the NPS of customers is different for the groups that saw different types of ads, implying that the type of retargeting has an effect on the NPS. Even though the medians of 'no retargeting' and 'generic retargeting' groups are the same, we can see the distribution of NPS for both groups; it is clear that after being exposed to generic retargeting ads instead of no retargeting at all, customers give our website higher scores, which should be considered while making a managerial decision regarding which type of promotion to use.

We should not forget to test for differences between groups using a **post-hoc test**. Nemenyi test for pairwise multiple comparisons of the ranked data can be used:
```{r warning = F, message = F}
library(PMCMRplus)
PMCMRplus::kwAllPairsNemenyiTest(x = customer_data_c$nps,
    g = customer_data_c$retargeting, dist = "Tukey")
```

It appears that the differences between median NPS for "no retargeting vs. generic retargeting", "generic retargeting vs. dynamic retargeting", and "no retargeting vs. dynamic retargeting" are significant.

**Assignment 2d:**

### Q7  
  
**Load data**

```{r warning=F, message=F, echo=T, eval=T}
customer_data_d <- read.table("https://raw.githubusercontent.com/WU-RDS/MA2022/main/data/data_4.csv", 
                          sep = ",", 
                          header = TRUE) #read in data
#head(customer_data_d)
#str(customer_data_d)
```

To find out if the new personalization feature has an effect on the conversion rate, we can use a test for proportions instead of a test for mean differences. To test for the equality of proportions (and therefore no difference between them) we can use a **chi-square ($\chi^2$) test**.

Our null hypothesis in this case states that **the proportions of conversion are the same for groups with and without the personalization feature**. Our alternative hypothesis states that these proportions are unequal.

$$H_0: \pi_1 = \pi_2 \\ H_1: \pi_1 \neq \pi_2$$

First, we will recode the relevant variables into factors and give them more descriptive level names:
```{r warning=FALSE, message=FALSE}
customer_data_d$conversion <- factor(customer_data_d$conversion, levels = c(0,1), labels = c("no", "yes"))
customer_data_d$exp_group <- factor(customer_data_d$exp_group, levels = c(0,1), labels = c("control", "treatment"))
```

Don't forget to create a summary plot to get a feeling for the data.

```{r fig.align="center", echo=TRUE, message = FALSE, warning = FALSE, fig.height=5, fig.width=6}
#conditional relative frequencies
rel_freq_table <- as.data.frame(prop.table(table(customer_data_d$exp_group, customer_data_d$conversion), 1))
names(rel_freq_table) <- c("group", "conversion", "freq") # changing names of the columns
rel_freq_table

library(colorspace)
ggplot(rel_freq_table, aes(x = group, y = freq, fill = conversion)) + #plot data
  geom_col(width = .7) + 
  geom_text(aes(label = paste0(round(freq*100,0), "%")), position = position_stack(vjust = 0.5), size = 4) + #add percentages
  ylab("Proportion of conversions") + xlab("group") + # specify axis labels
  theme_minimal() + 
  scale_fill_discrete_sequential(palette = "Reds 2", nmax = 4, order = 2:4)
```

We see that our conversion seems to be slightly better for the group with the personalization feature, but let´s check whether these proportions are significantly different.

```{r message=FALSE, warning=FALSE}
n1 <- nrow(subset(customer_data_d, exp_group == "control")) #number of observations for control group
n2 <- nrow(subset(customer_data_d, exp_group == "treatment"))  #number of observations for treatment group
n1_conv <- nrow(subset(customer_data_d, exp_group == "control" & conversion == "yes"))  #number of conversions for control group
n2_conv <- nrow(subset(customer_data_d, exp_group == "treatment" & conversion == "yes"))  #number of conversions for treatment group

prop.test(x = c(n1_conv, n2_conv), n = c(n1, n2), conf.level = 0.95, correct = FALSE) #without Yates correction
```


```{r echo=TRUE, message = FALSE, warning = FALSE}
table_1 <- table(customer_data_d$conversion,customer_data_d$exp_group)
chisq.test(table_1, correct = FALSE) #without Yates correction
```

```{r echo=TRUE, message = FALSE, warning = FALSE}
test_stat <- chisq.test(table_1, correct = FALSE)$statistic
n <- nrow(customer_data_d)
phi1 <- sqrt(test_stat/n)
phi1
```

It can be clearly seen from the test that **p-value is < 0.05**, so the result of the treatment on the conversion rate is **statistically significant**. We also calculated the effect size (*Cohen's d = Cramer's V = 0.026*): it is pretty small.


Finally, we can use `ggbarstats()` for the test results visualization:
```{r fig.align="center", echo=TRUE, message = FALSE, warning = FALSE, fig.width=6, fig.height=5}
library(ggstatsplot)
library(ghibli)
ggbarstats(data = customer_data_d, x = conversion, y = exp_group,
           title = "Conversion by experiment group", xlab = "Group", correct = TRUE,
           messages = FALSE, bar.proptest = FALSE,
           bf.message = FALSE) + 
  scale_fill_ghibli_d("PonyoLight") +
  theme_minimal()
```

The test (as well as the graph above) shows that **the conversion rate for the treatment group was higher than for the control group by 1 p.p.** This difference is though significant: **$\chi^2$ (1) = 7.35, p < .05 (95% CI = [0.003,0.02])**, but the effect size is rather tiny (Cohen's d = 0.026), so the personalization feature can be considered positive, but not too influential factor for conversion rate increase.


## Assignment 3

**Assignment A: Multiple linear regression**

```{r message = FALSE, warning = FALSE}
library(tidyverse)
library(psych)
library(Hmisc)
library(ggstatsplot)
library(ggcorrplot)
library(car)
library(lmtest)
library(lm.beta)
options(scipen = 999)
set.seed(123)

sales_data <- read.table("https://raw.githubusercontent.com/WU-RDS/MA2022/main/data/assignment4.dat", 
                          sep = "\t", 
                          header = TRUE) #read in data
sales_data$market_id <- 1:nrow(sales_data)
#head(sales_data)
#str(sales_data)
```

### Q1

In a first step, we specify the regression equation. In this case, sales is the **dependent variable** which is regressed on the different types of advertising expenditures that represent the **independent variables** for product *i*. Thus, the regression equation is:

$$Sales_{i}=\beta_0 + \beta_1 * tv\_adspend_{i} + \beta_2 * online\_adspend_{i} + \beta_3 * radio\_adspend_{i} + \epsilon_i$$
This equation will be used later to turn the output of the regression analysis (namely the coefficients: $\beta_0$ - intersect coefficient, and $\beta_1$, $\beta_2$, and $\beta_3$ that represent the unknown relationship between sales and advertising expenditures on TV, online channels and radio, respectively) to the "managerial" form and draw marketing conclusions.  

To save the formula, simply assign it to an object:
```{r message = FALSE, warning = FALSE}
formula <- sales ~ tv_adspend + online_adspend + radio_adspend
```

You can use this formula in the regression formula.

### Q2

The descriptive statistics can be checked using the ```describe()``` function:
  
```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, paged.print = FALSE}
psych::describe(sales_data)
```

Inspecting the correlation matrix reveals that the sales variable is positively correlated with TV advertising and online advertising expenditures. The correlations among the independent variables appear to be low to moderate. 
  
```{r eval = TRUE, echo = TRUE, warning = FALSE, message = FALSE}
rcorr(as.matrix(sales_data[,c("sales","tv_adspend","online_adspend","radio_adspend")]))
```

Since we have continuous variables, we use scatterplots to investigate the relationship between sales and each of the predictor variables.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
ggplot(sales_data, aes(x = tv_adspend, y = sales)) + geom_point(shape = 1) + geom_smooth(method = "lm", 
    fill = "gray", color = "lavenderblush3", alpha = 0.1) + theme_minimal()
ggplot(sales_data, aes(x = online_adspend, y = sales)) + geom_point(shape = 1) + geom_smooth(method = "lm", 
    fill = "gray", color = "lavenderblush3", alpha = 0.1) + theme_minimal()
ggplot(sales_data, aes(x = radio_adspend, y = sales)) + geom_point(shape = 1) + geom_smooth(method = "lm", 
    fill = "gray", color = "lavenderblush3", alpha = 0.1) + theme_minimal()
```

The plots including the fitted lines from a simple linear model already suggest that there might be a positive linear relationship between sales and TV- and online-advertising. However, there does not appear to be a strong relationship between sales and radio advertising. 

Further steps include estimate of a multiple linear regression model in order to determine the relative influence of each type of advertising on sales and test of the model's assumptions.

### Q3
                                                                                                                             The estimate the model, we will use the ```lm()``` function:
```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
linear_model <- lm(formula, data = sales_data) #estimate linear model
#summary(linear_model)
```
                                                                                                                             **Before** we can inspect the results, we need to test if there might be potential problems with our model specification. 

*Outliers*

To check for outliers, we extract the studentized residuals from our model and test if there are any absolute values larger than 3.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
sales_data$stud_resid <- rstudent(linear_model)
plot(1:nrow(sales_data), sales_data$stud_resid, ylim = c(-3.3, 3.3))
abline(h = c(-3, 3), col = "red", lty=2)
```

Since there are no residuals with absolute values larger than 3, we conclude that there are no severe outliers. 

*Influential observations*

To test for influential observations, we use Cook's Distance. You may use the following two plots to verify if any Cook's Distance values are larger than the cutoff of 1.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.show="hold", out.width="50%"}
plot(linear_model,4)
plot(linear_model,5)
```
Since all values are well below the cutoff, we conclude that influential observations are not a problem in our model. 
                                                                                                                             *Non-linear relationships*

Next, we test if a linear specification appears feasible. You could test this using the added variable plots:

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
avPlots(linear_model, col.lines = palette()[2])
```

The plots suggest that the linear specification is appropriate. In addition, you could also use the residuals plot to see if the linear specification is appropriate. The red line is a smoothed curve through the residuals plot and if it deviates from the dashed grey horizontal line a lot, this would suggest that a linear specification is not appropriate. 

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
plot(linear_model, 1)
```

In this example, the red line is close to the dashed grey line, so the linear specification appears reasonable. 

*Heteroscedasticity*

Next, we test if the residual variance is approximately the same at all levels of the predicted outcome variables (i.e., homoscedasticity). To do this, we use the residuals plot again.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
plot(linear_model, 1)
```

The spread of residuals at different levels of the predicted outcome does not appear to be very different. Thus, we can conclude that heteroscedasticity is unlikely to be a problem. We can also confirm this conclusion by using the Breusch-Pagan test, which shows an insignificant results, meaning that we cannot reject the Null Hypothesis of equal variances.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
bptest(linear_model)
```

*Non-normally distributed errors*

Next, we test if the residuals are approximately normally distributed using the Q-Q plot from the output:

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
plot(linear_model,2)
```

The Q-Q plot does not suggest a severe deviation from a normal distribution. This could also be validated using the Shapiro test (we again can't reject the Null Hypothesis that suggests normal distribution):

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
shapiro.test(resid(linear_model))
```

*Correlation of errors*

We actually wouldn't need to test this assumption here since there is not natural order in the data. 

*Multicollinearity*

To test for linear dependence of the regressors, we first test the bivariate correlations for any extremely high correlations (i.e., >0.8).

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
rcorr(as.matrix(sales_data[,c("tv_adspend","online_adspend","radio_adspend")]))
```

The results show that the bivariate correlations are low to moderate. This can also be shown in plots:

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.show="hold", out.width="50%"}
plot(sales_data[,c("tv_adspend","online_adspend","radio_adspend")])
ggcorrmat(data = sales_data[,c("tv_adspend", "online_adspend", "radio_adspend")],matrix.type = "upper",colors = c("skyblue4", "white", "palevioletred4")
#title = "Correlalogram of independent variables",
)
```

In the next step, we compute the variance inflation factor for each predictor variable. The values should be close to 1 and values larger than 4 indicate potential problems with the linear dependence of regressors.  

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
vif(linear_model)
```

Here, all VIF values are well below the cutoff, indicating that there are no problems with multicollinearity. 

### Q4

In a next step, we will investigate the results from the model using the ```summary()``` function.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
summary(linear_model)
```

For each of the individual predictors, we test the following hypothesis: 

$$H_0: \beta_k=0$$
$$H_1: \beta_k\ne0$$

where k denotes the number of the regression coefficient. In the present example, we reject the null hypothesis for tv_adspend and online_adspend, where we observe a significant effect (i.e., p < 0.05). However, we fail to reject the null for the "radio_adspend" variable (i.e., the effect is insignificant). 

The interpretation of the coefficients is as follows: 

* tv_adspend (&beta;<sub>1</sub>): when TV advertising expenditures increase by 1000 Euro, sales will increase by `r round(summary(linear_model)$coefficients[2],3)*1000` units;
* online_adspend (&beta;<sub>2</sub>): when online advertising expenditures increase by 1000 Euro, sales will increase by `r round(summary(linear_model)$coefficients[3],3)*1000` units;
* radio_adspend (&beta;<sub>3</sub>): when radio advertising expenditures increase by 1000 Euro, sales will increase by `r round(summary(linear_model)$coefficients[4],3)*1000` units (i.e., decrease by `r round(summary(linear_model)$coefficients[4],3)*1000*(-1)` units).

You should always provide a measure of uncertainty that is associated with the estimates. You could compute the confidence intervals around the coefficients using the ```confint()``` function.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
confint(linear_model)
```

The results show that, for example, with a 95% probability the effect of online advertising will be between 0.168 and 0.205. 

Although the variables are measured on the same scale, you should still test the relative influence by inspecting the standardized coefficients that express the effects in terms of standard deviations.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
lm.beta(linear_model)
```

Here, we conclude that TV advertising has the largest ROI followed by online advertising and radio advertising (that actually has negative effect).

Another significance test is the F-test. It tests the null hypothesis:
$$H_0: R^2=0$$
This is equivalent to the following null hypothesis: 

$$H_0: \beta_1=\beta_2=\beta_3=\beta_k=0$$
The result of the test is provided in the output above (**F-statistic: 468.1 on 3 and 232 DF,  p-value: < 2.2e-16**). Since the p-value is smaller than 0.05, we reject the null hypothesis that all coefficients are zero. 

Regarding the model fit, the R<sup>2</sup> statistic tells us that approximately 86% of the variance can be explained by the model. This can be visualized as follows: 

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
sales_data$yhat <- predict(linear_model)
ggplot(sales_data, aes(yhat, sales)) + 
  geom_point(size = 2, shape = 1) +
  scale_x_continuous(name = "predicted values") +
  scale_y_continuous(name = "observed values") +
  geom_abline(intercept = 0, slope = 1) +
  theme_minimal()
```

Of course, you could have also used the functions included in the ggstatsplot package to report the results from your regression model.

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE, fig.align="center", fig.width=7, fig.height=5}
ggcoefstats(x = linear_model, k = 3, title = "Sales predicted by adspend, airplay, & starpower")
```

### Q5

Finally, we can predict the outcome for the given marketing mix using the following equation: 
$$\hat{Sales} = \beta_0 + \beta_1*150 + \beta_2*26 + \beta_3*15 $$
The coefficients can be extracted from the summary of the linear model and used for quick sales value prediction as follows:

```{r message=FALSE, warning=FALSE, echo=TRUE, eval=TRUE}
summary(linear_model)$coefficients[1,1] + 
  summary(linear_model)$coefficients[2,1]*150 +
  summary(linear_model)$coefficients[3,1]*26 +
  summary(linear_model)$coefficients[4,1]*15
```

$$\hat{sales}= 3.6 + 0.045*150 + 0.187*26 + (-0.011)*15 = 15.11$$

This means that given the planned marketing mix, we would expect to sell around 15,112 units. 

Equivalently one can use the `predict` function 

```{r}
predict(linear_model, data.frame(tv_adspend = 150,online_adspend =  26,radio_adspend  =  15))
```

**Assignment B: Logistic regression**

```{r warning=FALSE, message=FALSE}
music_data <- read.csv2("https://raw.githubusercontent.com/WU-RDS/RMA2022/main/data/music_data_group.csv",
                        sep = ";", header = TRUE, dec = ",")
music_data$genre <- as.factor(music_data$genre)
music_data$label <- as.factor(music_data$label)
```

### Q6
                                                                                                                             For this model, we need to consider the logistic function, so the final mathematical representation (with three main predictors of interest so far) would look as follows:
                                                                                                                             $$f(\mathbf{X}) = P(y_i = 1) = \frac{1}{1 + e^{-(\beta_0 + \beta_1 * x_{1,i} + \beta_2 * x_{2,i} +\beta_3 * x_{3,i})}}$$
where $\beta_0$ is the intercept coefficient, and $\beta_1$, $\beta_2$, and $\beta_3$ represent the parameters of our model: weeks in charts, age of song, and label.

We should create the model using `glm()` and have a look at the summary:

```{r message = FALSE, warning = FALSE}
mult_logit_model <- glm(top10 ~ weeks_in_charts + song_age + label, family = binomial (link = 'logit'), data = music_data)
summary(mult_logit_model)
```

```{r}
confint(mult_logit_model)
```

From the summary of the model we can see that weeks in charts, age of song, and label can be used to predict if a song will end up in top-10 or not. We can also assess the model fit:

```{r}
logisticPseudoR2s <- function(LogModel) {
  dev <- LogModel$deviance
  nullDev <- LogModel$null.deviance
  modelN <- length(LogModel$fitted.values)
  R.l <-  1 -  dev / nullDev
  R.cs <- 1- exp(-(nullDev - dev) / modelN)
  R.n <- R.cs / ( 1 - (exp(-(nullDev / modelN))))
  cat("Pseudo R^2 for logistic regression\n")
  cat("Hosmer and Lemeshow R^2  ", round(R.l, 3), "\n")
  cat("Cox and Snell R^2        ", round(R.cs, 3), "\n")
  cat("Nagelkerke R^2           ", round(R.n, 3),    "\n")
}
#Inspect Pseudo R2s
logisticPseudoR2s(mult_logit_model)
```

To make conclusions about the effect that predictors have on success, we should convert the log-odds ratios to odds ratios using `exp()` function:

```{r}
exp(coef(mult_logit_model))
```

The results tell us, for example, that when a song is one week older, it is slightly less likely to get to the top-10 chart. If we are concerned about the labels to which the songs belong, we can see that in comparison to rather unknown (independent) labels, songs from Universal are 2.38 times more likely to appear in the top-10 chart.

We should visualize the relationship between IVs and DV:

```{r}
ggplot(music_data, aes(weeks_in_charts, top10)) +  
  geom_point(shape = 1) +
  geom_smooth(method = "glm",
              method.args = list(family = "binomial"),
              se = FALSE, color = "lavenderblush3") + theme_minimal()
ggplot(music_data, aes(song_age, top10)) + 
  geom_point(shape = 1) +
  geom_smooth(method = "glm",
              method.args = list(family = "binomial"),
              se = FALSE, color = "lavenderblush3") + theme_minimal()
```

There are several ways of plotting the effect of factor variables. Let's do it as follows to gain a better understanding of predicted values in logistic regression:

```{r}
library(forcats)
labels <- as.factor(c("Warner Music", "Sony Music", "Independent", "Universal Music"))
top10_predictions <- data.frame(pred = 
                                  predict(glm(top10 ~ label, data = music_data), 
                                          data.frame(label = labels), type = "response"), 
                                label = labels)
top10_counts <- table(music_data$top10, music_data$label)
top10_share <- prop.table(top10_counts, margin = 2)
data.frame(top10_share) |>
  dplyr::filter(Var1 == 1) |> 
  left_join(top10_predictions, by = c("Var2" = "label")) |>
  dplyr::rename(Share = Freq) |>
  ggplot(aes(fct_reorder(Var2, Share), Share)) +
  geom_bar(stat = 'identity', fill = "lavenderblush3") +
  geom_point(aes(x = Var2, y = pred), color = 'red4') +
  theme_minimal() +
  theme(axis.title.x = element_blank())
```

For factor variables, it would be also fine to plot the proportion plots (e.g., using `ggbarstats()` or `prop.table()` functions) as far as when considered separately, factor levels' proportions represent the exact probability of getting the 1 probability of a DV.  

To find out which other variables might have a significant effect on the chart performance, we can either load variables one-by-one manually or use a step-wise approach. For the latter, we basically need a model to start with (usually it's a "null" model, however, we already have a model that works for us, i.e., `mult_logit_model`) and the most loaded model that includes all the variables (we will only drop all character and date variables). Let's create it in the next step (please note that we already drop some variables that potentially might be influenced if a song appears in top-10: streams, sp_popularity, n_regions, etc.)

```{r}
music_data$explicit <- factor(music_data$explicit,levels = c(0,1), labels = c("not explicit", "explicit"))
full_model <- glm(top10 ~ weeks_in_charts + song_age + label + #our basic model. Next we add the rest of the variables to it:
                    danceability + energy + speechiness + instrumentalness + liveness + valence + tempo + song_length +
                    explicit + n_playlists + genre, family = binomial(link = 'logit'), data = music_data)
```

Let's have a look at how the fullest model possible works:

```{r}
summary(full_model)
```

We don't really need to go too much in details and apply step-by-step comparisons of the models using the suggested variables, so we can pick five significant factors from the summary above. For example, we can proceed with the model as follows:

```{r}
final_model <- glm(top10 ~ weeks_in_charts + song_age + label + #our basic model. Next we add the rest of the variables to it:
danceability + liveness + tempo + song_length + n_playlists,family = binomial(link = 'logit'), data = music_data)
summary(final_model)
```

```{r}
logisticPseudoR2s(final_model)
exp(coef(final_model))
#confint(final_model)
```

The interpretation of odds ratios stays the same (and should be discussed in your solution).
<br>

If we still want to choose a parsimonious model using step-wise comparisons, we can do it as follows: the function below takes the "base" model, adds variables from the fullest model one-by-one to it, and shows the new models' performance:

```{r}
step(mult_logit_model, #our base model
     scope = list(upper = full_model), 
     direction = "both",
     test = "Chisq",
     data = music_data)
```
<br>
<br>

-->